(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{318:function(e,a,s){"use strict";s.r(a);var n=s(1),l=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("div",{staticClass:"content"},[s("p",[e._v("我们知道，在 iOS的视图管理中，UIViewController是以栈的形式存储的。对于栈这种存储方式，最简单的理解为一个杯子，先放进杯子里的东西一定是最后被拿出来。当然在代码里我们可以实现删除栈中间的数据。\n对于刚刚入行没几年的开发者来讲，内存管理似乎不需要过多的关注。因为强大的arc已经替我们完成了大部分内存管理的工作。但实际上，arc这种引用计数机制在实际开发中仍然存在很多坑。比如我们在controller里写了这样的代码：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    _webView.UIDelegate = self;\n    _webView.navigationDelegate = self;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("大家都知道在viewcontroller生命周期结束后，要将delegate置为nil。我们通常会这样去写：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("- (void)dealloc {\n    self.webView.UIDelegate=nil;\n    self.webView.navigationDelegate=nil;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("这样的写法通常情况下不会出错，但是当UIViewController中存在内存泄漏时，比如在block中使用了self的强引用，造成循环引用导致dealloc函数无法执行，所以清空delegate的代码也就不会执行。为了防止这种情况出现，除了检查代码中是否存在循环引用的情况，我们可以把delegate的置空语句写在viewdiddisappear函数里。\n另外，如果你实在找不到究竟是哪句代码导致了内存泄漏，使得dealloc方法无法执行。就会想到强制从视图栈里移除当前controller")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("-(void)viewDidDisappear:(BOOL)animated{\n    [self removeFromParentViewController];\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("这样你可以打个断点看一下，dealloc函数是不是执行了。\n但是这样又出现了新的问题，当我们返回上一页的时候会发现，删除页的UINavigationBar没有从视图栈中移除，这样就需要点击两次返回才会返回到正常的页面。所以上面的方式行不通，我们可以这样写：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("-(void)viewDidDisappear:(BOOL)animated{\n    NSMutableArray *marr = [[NSMutableArray alloc]initWithArray:self.navigationController.viewControllers];\n//    for (UIViewController *vc in marr) {\n//        if ([vc isKindOfClass:[theVCYouWantToRemove class]]) {\n//            [marr removeObject:vc];\n//            break;\n//        }\n//    }\n    [marr removeObject:self];\n    self.navigationController.viewControllers = marr;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("当然在写代码的时候就做好内存管理及优化才是最好的方法。")])])}],!1,null,null,null);a.default=l.exports}}]);